<?xml version="1.0"?>

<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is BlueGriffon.
   -
   - The Initial Developer of the Original Code is
   - Disruptive Innovations SARL.
   - Portions created by the Initial Developer are Copyright (C) 2006
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -   Daniel Glazman (daniel.glazman@disruptive-innovations.com), Original Author
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->


<bindings id="rulersBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:svg="http://www.w3.org/2000/svg">

  <binding id="ruler-base">

  	<implementation>

      <constructor>
        <![CDATA[
          NotifierUtils.addNotifierCallback("selection",      this.selectionChanged, this);
          NotifierUtils.addNotifierCallback("resizeEvent",    this.onResizeEvent, this);
          NotifierUtils.addNotifierCallback("editorScrolled", this.onEditorScrolled, this);
        ]]>
      </constructor>

      <field name="kSVG_NS">"http://www.w3.org/2000/svg"</field>

      <field name="mPos">0</field>
      <field name="mSize">0</field>
      <field name="mSource">null</field>
      <field name="mRulerSeparatorPosition">null</field>
      <field name="mResizing">false</field>
      <field name="mRuleSeparator">null</field>

      <method name="onEditorScrolled">
        <body>
        <![CDATA[
          var elt = EditorUtils.getSelectionContainer().node;
          this.selectionChanged(null, elt, true);
        ]]>
        </body>
      </method>

      <method name="onResizeEvent">
        <body>
        <![CDATA[
          var elt = EditorUtils.getSelectionContainer().node;
          this.selectionChanged(null, elt, true);
        ]]>
        </body>
      </method>

      <method name="selectionChanged">
        <parameter name="aArguments"/>
        <parameter name="aNode"/>
        <parameter name="aOneElementSelected"/>
        <body>
        <![CDATA[
          var node = aNode;
          var display = this.getComputedStyle(aNode).getPropertyValue("display");
          while (node &&
                 display != "block" &&
                 display != "inline-block" &&
                 display != "table" &&
                 display != "table-cell" &&
                 display != "list-item" &&
                 node.nodeName.toLowerCase() != "img")
          {
            node = node.parentNode;
            display = this.getComputedStyle(node).getPropertyValue("display");
          }
          this.clean();
          if (node instanceof Components.interfaces.nsIDOMHTMLTableCellElement)
          {
            var child = node;
            while (child.previousSibling)
              child = child.previousSibling;
            while (child)
            {
              if (child.nodeType == Node.ELEMENT_NODE)
                this._showElementRuler(child);
              child = child.nextSibling;
            }
          }
          else
            this._showElementRuler(node);
        ]]>
        </body>
      </method>

      <method name="getComputedStyle">
        <parameter name="aElt"/>
        <body>
        <![CDATA[
          return aElt.ownerDocument.defaultView.getComputedStyle(aElt, "");
        ]]>
        </body>
      </method>

      <property name="mSVGGroup">
        <getter>
        <![CDATA[
          return document.getAnonymousElementByAttribute(this, "anonid", "SVGGroup");
        ]]>
        </getter>
      </property>

      <property name="mHTMLcontainer">
        <getter>
        <![CDATA[
          return document.getAnonymousElementByAttribute(this, "anonid", "HTMLcontainer");
        ]]>
        </getter>
      </property>

      <method name="clean">
        <body>
        <![CDATA[
          var svgGroup = this.mSVGGroup;
          var child = svgGroup.firstChild;
          while (child)
          {
            var tmp = child.nextSibling;
            svgGroup.removeChild(child);
            child = tmp;
          }
        ]]>
        </body>
      </method>


  	</implementation>
  </binding>

  <binding id="hruler" extends="chrome://bluegriffon/content/bindings/rulers.xml#ruler-base">
    <content>
        <html:div anonid="HTMLcontainer"
        					style="margin: 0px; padding: 0px; width: 100%!important; height: 100%">
        	<svg:svg style="width: 100% ! important; height: 16px;" height="16"
        					 preserveAspectRatio="xMidYMid meet">
        		<svg:g anonid="SVGGroup"/>
    		  </svg:svg>
    		</html:div>
    </content>

    <implementation>

      <field name="mOriginalX">0</field>
      <field name="mMarginLeft">0</field>
      <field name="mWidth">0</field>

      <method name="_showElementRuler">
        <parameter name="aElt"/>
        <body>
        <![CDATA[
          var w = aElt.clientWidth;
          var x = aElt.offsetLeft + 12;
          var o = aElt;
          while (o.offsetParent)
          {
            o = o.offsetParent;
            x += o.offsetLeft;
          }
          if (aElt instanceof Components.interfaces.nsIDOMHTMLTableCellElement)
          {
            var cs = this.getComputedStyle(aElt);
            var pl = cs.getPropertyCSSValue("padding-left");
            var pr = cs.getPropertyCSSValue("padding-right");

            if (pl.primitiveType == CSSPrimitiveValue.CSS_PX)
            {
              var plv = pl.getFloatValue(CSSPrimitiveValue.CSS_PX);
              x += plv;
              w -= plv;
            }
            if (pr.primitiveType == CSSPrimitiveValue.CSS_PX)
            {
              var prv = pr.getFloatValue(CSSPrimitiveValue.CSS_PX);
              w -= prv;
            }
          }
          this.addObject("hruler", x, w, aElt);
        ]]>
        </body>
      </method>

      <property name="mScrollX">
        <getter>
        <![CDATA[
          return EditorUtils.getCurrentEditorElement() ?
                   EditorUtils.getCurrentEditorElement().contentWindow.scrollX :
                   0;
        ]]>
        </getter>
      </property>

      <method name="addObject">
      	<parameter name="aName"/>
      	<parameter name="aPos"/>
      	<parameter name="aSize"/>
      	<parameter name="aSource"/>
        <body>
        <![CDATA[
          this.mPos  = aPos;
          this.mSize = aSize; 
        
          var svgGroup = this.mSVGGroup;
          var realRulerSize = this.mHTMLcontainer.clientWidth;
          var g = document.createElementNS(this.kSVG_NS, "g");

          var r = document.createElementNS(this.kSVG_NS, "rect")
          r.setAttribute("x", (100*(aPos-this.mScrollX)/realRulerSize) + "%");
          r.setAttribute("y", "0");
          r.setAttribute("width", (100*aSize/realRulerSize) + "%");
          r.setAttribute("height", "16");
          r.setAttribute("anonid", "ruler");
          r.setAttribute("style", "fill: white; stroke-width: 1px; stroke: gray");

          var lH = document.createElementNS(this.kSVG_NS, "rect")
          lH.setAttribute("x", (100*(aPos-this.mScrollX)/realRulerSize) + "%");
          lH.setAttribute("y", "0");
          lH.setAttribute("width", (100*4/realRulerSize) + "%");
          lH.setAttribute("height", "16");
          lH.setAttribute("style", "fill: gray; stroke-width: 1px; stroke: gray; cursor: w-resize");
          lH.setAttribute("ruler-position", aPos-12);
          lH.setAttribute("ruler-size", aSize);
          lH.setAttribute("class", "hruler-separator");
          lH.setAttribute("ruler-separator-position", "left");
          lH.setUserData("source", aSource, null);

          var rH = document.createElementNS(this.kSVG_NS, "rect")
          rH.setAttribute("x", (100*(aPos+aSize-4-this.mScrollX)/realRulerSize) + "%");
          rH.setAttribute("y", "0");
          rH.setAttribute("width", (100*4/realRulerSize) + "%");
          rH.setAttribute("height", "16");
          rH.setAttribute("style", "fill: gray; stroke-width: 1px; stroke: gray; cursor: w-resize");
          rH.setAttribute("ruler-position", aPos-12);
          rH.setAttribute("ruler-size", aSize);
          rH.setAttribute("class", "hruler-separator");
          rH.setAttribute("ruler-separator-position", "right");
          rH.setUserData("source", aSource, null);

          var t = document.createElementNS(this.kSVG_NS, "text");
          t.setAttribute("x", (100*(aPos-this.mScrollX+aSize/2)/realRulerSize) + "%");
          t.setAttribute("y", "50%");

          var text = document.createTextNode(aSize + "px");
          t.appendChild(text);

          g.appendChild(r);
          g.appendChild(lH);
          g.appendChild(rH);
          g.appendChild(t);
          svgGroup.appendChild(g);
        ]]>
        </body>
      </method>

    </implementation>

    <resources>
      <stylesheet src="chrome://bluegriffon/skin/rulers.css"/>
    </resources>

    <handlers>
      <handler event="mousedown">
        <![CDATA[
          var elt = event.originalTarget;
          if (elt.getAttribute("class") != "hruler-separator")
            return; 

          this.mRulerSeparatorPosition = elt.getAttribute("ruler-separator-position");

          this.mOriginalX = event.clientX; 
          this.mSource = elt.getUserData("source");
          this.mMarginLeft = parseFloat(this.getComputedStyle(mSource).getPropertyValue("margin-left"));
          if (!this.mMarginLeft)
            this.mMarginLeft = 0; 
          this.mWidth = this.mSource.clientWidth;
          this.mRuleSeparator = elt;

          this.mResizing = true;
        ]]>
      </handler>

      <handler event="mousemove">
        <![CDATA[
          if (!this.mResizing)
            return;

          var x = event.clientX;
          var realRulerSize = this.mHTMLcontainer.clientWidth;

          switch (this.mRulerSeparatorPosition)
          {
            case "left":
              this.mRuleSeparator.setAttribute("x",
                 (100*(this.mPos - this.mOriginalX + x - this.mScrollX)/realRulerSize) + "%");
              // update main ruler element
              this.mRuleSeparator.parentNode.firstChild
                .setAttribute("x", (100*(this.mPos - this.mOriginalX + x- this.mScrollX)/realRulerSize) + "%");
              this.mRuleSeparator.parentNode.firstChild
                .setAttribute("width", (100*(this.mSize + this.mOriginalX - x)/realRulerSize) + "%");
              // update text
              this.mRuleSeparator.parentNode.lastChild
                .setAttribute("x", (100*((this.mPos - this.mOriginalX + x- this.mScrollX)+(this.mSize + this.mOriginalX - x)/2)/realRulerSize) + "%");
              this.mRuleSeparator.parentNode.lastChild.firstChild
                .data = (this.mSize + this.mOriginalX - x) + "px";
              break;
            case "right":
              this.mRuleSeparator.setAttribute("x",
                 (100*(this.mPos - this.mOriginalX + x + this.mSize - 4- this.mScrollX)/realRulerSize) + "%");
              // update main ruler element
              this.mRuleSeparator.parentNode.firstChild
                .setAttribute("width", (100*(this.mSize - this.mOriginalX + x)/realRulerSize) + "%");
              // update text
              this.mRuleSeparator.parentNode.lastChild
                .setAttribute("x", (100*(this.mPos - this.mScrollX + (this.mSize - this.mOriginalX + x)/2)/realRulerSize) + "%");
              this.mRuleSeparator.parentNode.lastChild.firstChild
                .data = (this.mSize - this.mOriginalX + x) + "px";
              break;
            default: break;
          }
        ]]>
      </handler>

      <handler event="mouseup">
        <![CDATA[
          if (!this.mResizing)
            return;

          this.mResizing = false;
          this.mRuleSeparator = null;

          var x = event.clientX;
          var realRulerSize = this.mHTMLcontainer.clientWidth;
          var styleAttrValue = this.mSource.getAttribute("style");
          if (styleAttrValue)
            styleAttrValue += ";"
          else
            styleAttrValue = "";
          switch (this.mRulerSeparatorPosition)
          {
            case "left":
              styleAttrValue += "margin-left: " + (this.mMarginLeft - this.mOriginalX +
                                               x) + "px";
              styleAttrValue += "; width: " + (this.mWidth  + this.mOriginalX -
                                          x) + "px";
              break;
            case "right":
              styleAttrValue += "width: " + (this.mWidth  - this.mOriginalX +
                                          x) + "px";
              break;
            default: break;
          }
          EditorUtils.getCurrentEditor()
            .setAttribute(this.mSource, "style", styleAttrValue);
          this.selectionChanged(null, this.mSource, null);
        ]]>
      </handler>

    </handlers>

  </binding>

  <binding id="vruler">

    <content>

        <html:div style="margin:0;padding: 0; width: 100%!important; height: 100%;">
          <svg:svg style="width: 16px ! important; height: 98%" viewBox="0 0 16 100"
                   preserveAspectRatio="xMidYMid meet">
            <svg:g>
              <svg:text transform="rotate(-90,8,50)" x="50%" y="50%">foo</svg:text>
            </svg:g>
          </svg:svg>
        </html:div>

    </content>
    <resources>
      <stylesheet src="chrome://bluegriffon/skin/rulers.css"/>
    </resources>

  </binding>

</bindings>
