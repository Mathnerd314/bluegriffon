<?xml version="1.0"?>

<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is BlueGriffon.
   -
   - The Initial Developer of the Original Code is
   - Disruptive Innovations SAS.
   - Portions created by the Initial Developer are Copyright (C) 2013
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -   Daniel Glazman (daniel.glazman@disruptive-innovations.com), Original Author
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->


<!DOCTYPE bindings [
  <!ENTITY % responsiveRulerBindingsDTD SYSTEM "chrome://bluegriffon/locale/responsive.dtd" >
  %responsiveRulerBindingsDTD;
]>

<bindings id="responsiveRulerBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:svg="http://www.w3.org/2000/svg">

  <binding id="responsiveRuler">

     <resources>
      <stylesheet src="chrome://bluegriffon/skin/responsive.css"/>
    </resources>

     <content>
        <xul:panel type="arrow" anonid="infoPopup" orient="vertical">
          <xul:grid>
            <xul:columns>
              <xul:column/>
              <xul:column/>
            </xul:columns>
            <xul:rows>
              <xul:row align="center">
                <xul:label value="&markerPosition.label;"/>
                <xul:textbox type="number" anonid="infoMarkerPosition"
                             oncommand="CheckMarkerWidthChange(this)"
                             oninput="CheckMarkerWidthChange(this)"/>
              </xul:row>
              <xul:row>
                <xul:spacer/>
                <xul:hbox>
                  <xul:spacer flex="1"/>
                  <xul:button label="&deleteMarker.label;"/>
                  <xul:button label="&updateMarker.label;" anonid="updateMarker" disabled="true"
                              oncommand="UpdateMarker()"/>
                </xul:hbox>
              </xul:row>
            </xul:rows>
          </xul:grid>          
        </xul:panel>
        <svg:svg
             height="34"
             anonid="svg"
             xmlns="http://www.w3.org/2000/svg"
             preserveAspectRatio="xMidYMid meet">
          <svg:g anonid="SVGbg">
            <svg:rect class="rulerBackground" x="0" y="10" width="100%" height="24" />
            <svg:rect class="rulerTop"        x="0" y="10" width="100%" height="1" />
          </svg:g>
          <svg:g anonid="SVGGroup"/>
          <svg:g anonid="SVGmarkers"/>
        </svg:svg>
      </content>

    <implementation>

      <constructor>
        <![CDATA[
          NotifierUtils.addNotifierCallback("zoom",        this.onZoom, this);
          NotifierUtils.addNotifierCallback("tabSelected", this.reset,  this);
          this.init();
          this.reset();
        ]]>
      </constructor>

      <destructor>
        <![CDATA[
          NotifierUtils.removeNotifierCallback("zoom",        this.onZoom, this);
          NotifierUtils.removeNotifierCallback("tabSelected", this.reset,  this);
        ]]>
      </destructor>

      <field name="mRegexp">/(only\s)?screen\s+and\s+\(max\-width\s*:\s*(\d*(\.\d*)?)px\)/;</field>

      <property name="currentQuery" readonly="true">
        <getter>
        <![CDATA[
          var SVGmarkers = this.getChild("SVGmarkers");
          var path = SVGmarkers.querySelector('path[selected]');
          if (path)
            return parseFloat(path.getAttribute("query"))
          return null;
        ]]>
        </getter>
      </property>

      <method name="init">
        <body><![CDATA[
          var zoom = this.getZoom();

          var svg = this.getChild("svg");
          var SVGGroup = this.getChild("SVGGroup");

          deleteAllChildren(SVGGroup);

          for (i = 0; i < 5000; i += 5) {
            var n = i/100;
            if (n == Math.floor(n)) {
              var e = document.createElementNS("http://www.w3.org/2000/svg", "rect");
              e.setAttribute("width", "1");
              e.setAttribute("height", "10");
              e.setAttribute("x", i * zoom);
              e.setAttribute("y", "10");
              SVGGroup.appendChild(e);
  
              var f = document.createElementNS("http://www.w3.org/2000/svg", "text");
              f.setAttribute("x", i * zoom);
              f.setAttribute("y", "30");
              f.textContent = i;
              SVGGroup.appendChild(f);
            }
            else if (n*10 == Math.floor(n*10)){
              var e = document.createElementNS("http://www.w3.org/2000/svg", "rect");
              e.setAttribute("width", "1");
              e.setAttribute("height", "5");
              e.setAttribute("x", i * zoom);
              e.setAttribute("y", "10");
              SVGGroup.appendChild(e);
            }
          }
        ]]></body>
      </method>

      <method name="CheckMarkerWidthChange">
        <parameter name="aElt"/>
        <body><![CDATA[
          var v = parseFloat(aElt.getAttribute("originalValue"));
          if (v != aElt.value)
            this.getChild("updateMarker").removeAttribute("disabled");
          else
            this.getChild("updateMarker").setAttribute("disabled", "true");
        ]]></body>
      </method>

      <method name="UpdateMarker">
        <body><![CDATA[
          Components.utils.import("resource://app/modules/editorHelper.jsm");
          Components.utils.import("resource://app/modules/urlHelper.jsm");
          Components.utils.import("resource://app/modules/cssHelper.jsm");
          Components.utils.import("resource://app/modules/cssInspector.jsm");

          var ov = this.getChild("infoMarkerPosition").getAttribute("originalValue");
          var v  = this.getChild("infoMarkerPosition").value;

          var doc = EditorUtils.getCurrentDocument();
          if (!doc) // early way out, nothing to do
            return;

          var queries = [];
          var ss = doc.styleSheets;
          for (var i = 0; i < ss.length; i++) {
            this._collectMediaQueries(ss[i], queries, true);
          }
          var sheets = [];
          for (var i = 0; i < queries.length; i++) {
            if (queries[i].v == ov) {
              var o = queries[i].o;
              o.media.mediaText = "only screen and (max-width: " + v + "px)";
              var sheet = null;
              if (o instanceof CSSRule)
                sheet = o.parentStyleSheet;
              else
                sheet = o;
              if (sheets.indexOf(sheet) == -1)
                sheets.push(sheet);
            }
          }
          for (var i = 0; i < sheets.length; i++) {
            var sheet = sheets[i];
            if (sheet.ownerNode && sheet.ownerNode.href)
              CssInspector.serializeFileStyleSheet(sheet, sheet.href);
            else
              CssUtils.reserializeEmbeddedStylesheet(sheet, EditorUtils.getCurrentEditor());
          }
          var SVGmarkers = this.getChild("SVGmarkers");
          var path = SVGmarkers.querySelector('path[query="' + ov + '"]');
          var zoom = this.getZoom();
          if (path) {
            var x = parseFloat(v);
            path.setAttribute("d", "M " + (x * zoom) + " 10 L" + ((x * zoom)-10) + " 0 L" + ((x * zoom)+10) + " 0  Z");
            path.setAttribute("query", x);
            path.nextElementSibling.textContent = x;
            path.nextElementSibling.setAttribute("x", x * zoom - 11);
          }
          this.getChild("infoPopup").hidePopup();
        ]]></body>
      </method>

      <method name="onZoom">
        <parameter name="aEvent"/>
        <body><![CDATA[
          this.init();
          this.reset();
        ]]></body>
      </method>

      <method name="onClick">
        <parameter name="aEvent"/>
        <body><![CDATA[
        ]]></body>
      </method>

      <method name="onSplitter">
        <parameter name="aEvent"/>
        <body><![CDATA[
          if (!EditorUtils.getCurrentEditorElement().hasAttribute("width"))
            return;

          var SVGmarkers = this.getChild("SVGmarkers");
          var paths = SVGmarkers.querySelectorAll("path");
          var queries = [];
          for (var i = 0; i < paths.length; i++) {
            paths[i].removeAttribute("selected");
            queries.push(parseFloat(paths[i].getAttribute("query")));
          }
          queries.sort(function(a,b){if (a<b) return -1; if (a>b) return 1; return 0;});

          var query = -1;
          var w = parseFloat(EditorUtils.getCurrentEditorElement().getAttribute("width"));
          for (var i = 0; query == -1 && i < queries.length; i++) {
            if (queries[i] >= w)
              query = queries[i];
          }
          if (query != -1) {
            var path = SVGmarkers.querySelector('path[query="' + query + '"]');
            if (path)
              path.setAttribute("selected", "true");
          }
          var node = EditorUtils.getSelectionContainer().node;
          NotifierUtils.notify("selection", node, true);
        ]]></body>
      </method>

      <method name="getZoom">
        <body><![CDATA[
          var zoom = 1;
          if (EditorUtils.getCurrentEditorElement())
            zoom = BGZoomManager.getCurrentZoom();
          return zoom;
        ]]></body>
      </method>

      <method name="addMarker">
        <parameter name="x"/>
        <parameter name="aIsRefresh"/>
        <body><![CDATA[
          var zoom = this.getZoom();
          if (!aIsRefresh)
            x = x / zoom;

          var SVGmarkers = this.getChild("SVGmarkers");
          var e = document.createElementNS("http://www.w3.org/2000/svg", "path");
          e.setAttribute("d", "M " + (x * zoom) + " 10 L" + ((x * zoom) - 10) + " 0 L" + ((x * zoom) + 10) + " 0  Z");
          e.setAttribute("query", x);
          SVGmarkers.appendChild(e);

          var f = document.createElementNS("http://www.w3.org/2000/svg", "text");
          f.setAttribute("text-anchor", "end");
          f.setAttribute("font-size", "8pt");
          f.setAttribute("x", x * zoom - 11);
          f.setAttribute("y", "10");
          f.textContent = x;
          SVGmarkers.appendChild(f);

          this.onSplitter();
        ]]></body>
      </method>

      <method name="getChild">
        <parameter name="aChildName"/>
        <body><![CDATA[
          return document.getAnonymousElementByAttribute(this, "anonid", aChildName);
        ]]></body>
      </method>

      <method name="_collectMediaQueries">
        <parameter name="aSheet"/>
        <parameter name="aQueries"/>
        <parameter name="aCollectRules"/>
        <body><![CDATA[
          if (!aSheet)
            return;
          if (aSheet.media &&
              aSheet.media.mediaText) {
            var m = aSheet.media.mediaText.match(this.mRegexp);
            if (m) {
              if (aCollectRules)
                aQueries.push( { o: aSheet, v: m[2] } );
              else
                aQueries.push(m[2]);
            }
          }
          this._collectMediaQueriesFromRules(aSheet.cssRules, aQueries, aCollectRules);
        ]]></body>
      </method>

      <method name="_collectMediaQueriesFromRules">
        <parameter name="aRules"/>
        <parameter name="aQueries"/>
        <parameter name="aCollectRules"/>
        <body><![CDATA[
          for (var i = 0; i < aRules.length; i++) {
            var rule = aRules[i];
            switch (rule.type) {
              case CSSRule.IMPORT_RULE:
                this._collectMediaQueries(rule.styleSheet, aQueries, aCollectRules);
                break;
              case CSSRule.MEDIA_RULE:
                if (rule.media.mediaText) {
                  var m = rule.media.mediaText.match(this.mRegexp);
                  if (m) {
                    if (aCollectRules)
                      aQueries.push( { o: rule, v: m[2] } );
                    else
                      aQueries.push(m[2]);
                  }
                }
                break;
              default: break;
            }
          }
        ]]></body>
      </method>

      <method name="reset">
        <body><![CDATA[
          var SVGmarkers = this.getChild("SVGmarkers");

          // first clear all existing markers
          var paths = SVGmarkers.querySelectorAll("path,text");
          for (var i = 0; i < paths.length; i++) {
            SVGmarkers.removeChild(paths[i]);
          }

          var doc = EditorUtils.getCurrentDocument();
          if (!doc) // early way out, nothing to do
            return;
          var queries = [];
          var ss = doc.styleSheets;
          for (var i = 0; i < ss.length; i++) {
            this._collectMediaQueries(ss[i], queries, false);
          }
          for (var i = 0; i < queries.length; i++) {
            this.addMarker(parseFloat(queries[i]), true);
          }
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="click" button="2" clickcount="1">
        <![CDATA[
          if (event.originalTarget.localName == "path") {
            var v = event.originalTarget.getAttribute("query");
            this.getChild("infoMarkerPosition").setAttribute("originalValue", v);
            this.getChild("infoMarkerPosition").value = v;
            this.getChild("updateMarker").setAttribute("disabled", "true");
            this.getChild("infoPopup").openPopup(event.originalTarget, "after_start", 0, 21,
                                                 false, true);
          }
        ]]>
      </handler>

      <handler event="click" button="0" clickcount="1">
        <![CDATA[
          var editorElement = EditorUtils.getCurrentEditorElement();
          var e = event.originalTarget;
          if (e.localName == "text" &&
              e.parentNode.getAttribute("anonid") == "SVGmarkers") {
            e = e.previousElementSibling;
            event = { originalTarget: e };
          }
          switch (e.localName) {
            case "rect":
            case "text":
              this.addMarker(event.layerX, false);
              break;
            case "svg":
              {
                var zoom = this.getZoom();
                var x = event.layerX / zoom;

                var SVGmarkers = this.getChild("SVGmarkers");
                var paths = SVGmarkers.querySelectorAll("path");
                var queries = [];
                for (var i = 0; i < paths.length; i++) {
                  queries.push(parseFloat(paths[i].getAttribute("query")));
                }
                queries.sort(function(a,b){if (a<b) return -1; if (a>b) return 1; return 0;});
      
                var query = -1;
                for (var i = 0; query == -1 && i < queries.length; i++) {
                  if (queries[i] >= x)
                    query = queries[i];
                }
                event = null;
                if (query != -1) {
                  var path = SVGmarkers.querySelector('path[query="' + query + '"]');
                  if (path)
                    event = { originalTarget: path };
                }
              }
              // no break on purpose
            case "path":
              {
                var SVGmarkers = this.getChild("SVGmarkers");
                var paths = SVGmarkers.querySelectorAll("path");
                var oneSelected = false;
                for (var i = 0; i < paths.length; i++) {
                  if (paths[i].hasAttribute("selected")) {
                    oneSelected = true;
                    paths[i].removeAttribute("selected");
                  }
                }
                if (event) {
                  event.originalTarget.setAttribute("selected", "true");
                  editorElement.removeAttribute("flex");
                  if (editorElement.hasAttribute("width")) {
                    editorElement.setAttribute("noTransition", "true");
                    editorElement.setAttribute("style",
                        "width: " +
                        editorElement.getAttribute("width") + "px");
                    editorElement.removeAttribute("width");
                  }
                  else if (!oneSelected) {
                    editorElement.setAttribute("style",
                        "width: " +
                        document.defaultView.getComputedStyle(this, "").getPropertyValue("width"));
                  }
                  var _self = this;
                  var zoom = this.getZoom();
                  setTimeout(function(a,b){
                               editorElement.removeAttribute("noTransition");
                               editorElement.setAttribute(a,b);
                               editorElement.parentNode.lastChild.removeAttribute("width");
                               editorElement.parentNode.lastChild.setAttribute("flex", "1");
                             }, 100,
                             "style", "width: " + parseFloat(event.originalTarget.getAttribute("query") * zoom) + "px");
                }
                else {
                  var tm = 0;
                  if (editorElement.hasAttribute("width")) {
                      var w = editorElement.getAttribute("width");
                      editorElement.setAttribute("noTransition", "true");
                      editorElement.removeAttribute("width");
                      editorElement.setAttribute("style", "width: " + w + "px");
                      editorElement.parentNode.lastChild.setAttribute("flex", "1");
                      tm = 100;
                  }
                  var _self = this;
                  setTimeout(function() {
                      editorElement.removeAttribute("noTransition");
                      editorElement.setAttribute("style",
                          "width: " +
                          document.defaultView.getComputedStyle(_self, "").getPropertyValue("width"));
                      setTimeout(function(a,b){ editorElement.setAttribute(a,b);
                                                editorElement.removeAttribute("style");
                                                editorElement.removeAttribute("width");
                                                editorElement.parentNode.lastChild.removeAttribute("flex");
                                                editorElement.parentNode.lastChild.setAttribute("width", "0");
                                              }, 200,
                                 "flex", "1");
                    }, tm);
                }
              }
              var node = EditorUtils.getSelectionContainer().node;
              NotifierUtils.notify("selection_strict", node, true);

              break;
          }
        ]]>
      </handler>
    </handlers>

  </binding>
</bindings>
      