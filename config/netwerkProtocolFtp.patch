diff -r 51249e968f24 netwerk/protocol/ftp/public/nsIFTPChannel.idl
--- a/netwerk/protocol/ftp/public/nsIFTPChannel.idl	Mon Nov 24 11:36:44 2008 +0100
+++ b/netwerk/protocol/ftp/public/nsIFTPChannel.idl	Wed Jan 14 18:15:50 2009 +0100
@@ -37,12 +37,41 @@
 
 #include "nsISupports.idl"
 
+interface nsIURI;
+
 /**
  * This interface may be used to determine if a channel is a FTP channel.
  */
-[scriptable, uuid(2315d831-8b40-446a-9138-fe09ebb1b720)]
+[scriptable, uuid(deb19f2a-ad32-47c4-85f4-b799fd7f1e51)]
 interface nsIFTPChannel : nsISupports
 {
+  /**
+   * This method prepares the channel for the deletion of a file. The
+   * deletion itself will be performed when the channel is opened,
+   * synchronously or not.
+   */
+  void deleteFile();
+
+  /**
+   * This method prepares the channel for the creation of a new directory.
+   * The creation itself will be performed when the channel is opened,
+   * synchronously or not.
+   */
+  void createDirectory();
+
+  /**
+   * This method prepares the channel for the removal of a directory.
+   * The removal itself will be performed when the channel is opened,
+   * synchronously or not.
+   */
+  void removeDirectory();
+
+  /*
+   * This method prepares the channel for renaming. The renaming itself
+   * will be performed when the channel is opened,
+   * synchronously or not.
+   */
+  void renameTo(in nsIURI aNewURI);
 };
 
 /**
diff -r 51249e968f24 netwerk/protocol/ftp/src/nsFTPChannel.cpp
--- a/netwerk/protocol/ftp/src/nsFTPChannel.cpp	Mon Nov 24 11:36:44 2008 +0100
+++ b/netwerk/protocol/ftp/src/nsFTPChannel.cpp	Wed Jan 14 18:15:50 2009 +0100
@@ -154,6 +154,14 @@
         return NS_ERROR_OUT_OF_MEMORY;
     NS_ADDREF(state);
 
+    (void) state->ScheduleForFileDeletion(mScheduledForDELE);
+    (void) state->ScheduleForDirCreation(mScheduledForMKD);
+    (void) state->ScheduleForDirRemoval(mScheduledForRMD);
+    (void) state->ScheduleForRenaming(mScheduledForRNFR, mScheduledNewURI);
+
+    // clear all schedules for future use of the channel
+    ClearSchedules(PR_FALSE);
+
     nsresult rv = state->Init(this);
     if (NS_FAILED(rv)) {
         NS_RELEASE(state);
@@ -197,3 +205,38 @@
     }
     aResult = mFTPEventSink;
 }
+
+//-----------------------------------------------------------------------------
+
+NS_IMETHODIMP
+nsFtpChannel::DeleteFile()
+{
+  ClearSchedules(PR_TRUE);
+  mScheduledForDELE = PR_TRUE;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsFtpChannel::CreateDirectory()
+{
+  ClearSchedules(PR_TRUE);
+  mScheduledForMKD = PR_TRUE;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsFtpChannel::RemoveDirectory()
+{
+  ClearSchedules(PR_TRUE);
+  mScheduledForRMD = PR_TRUE;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsFtpChannel::RenameTo(nsIURI * aNewURI)
+{
+  ClearSchedules(PR_TRUE);
+  mScheduledForRNFR = PR_TRUE;
+  mScheduledNewURI = aNewURI;
+  return NS_OK;
+}
diff -r 51249e968f24 netwerk/protocol/ftp/src/nsFTPChannel.h
--- a/netwerk/protocol/ftp/src/nsFTPChannel.h	Mon Nov 24 11:36:44 2008 +0100
+++ b/netwerk/protocol/ftp/src/nsFTPChannel.h	Wed Jan 14 18:15:50 2009 +0100
@@ -80,11 +80,16 @@
     NS_DECL_NSIUPLOADCHANNEL
     NS_DECL_NSIRESUMABLECHANNEL
     NS_DECL_NSIPROXIEDCHANNEL
+    NS_DECL_NSIFTPCHANNEL
     
     nsFtpChannel(nsIURI *uri, nsIProxyInfo *pi)
         : mProxyInfo(pi)
         , mStartPos(0)
         , mResumeRequested(PR_FALSE)
+        , mScheduledForDELE(PR_FALSE)
+        , mScheduledForMKD(PR_FALSE)
+        , mScheduledForRMD(PR_FALSE)
+        , mScheduledForRNFR(PR_FALSE)
     {
         SetURI(uri);
     }
@@ -121,6 +126,21 @@
                                        nsIChannel** channel);
     virtual PRBool GetStatusArg(nsresult status, nsString &statusArg);
     virtual void OnCallbacksChanged();
+    inline void ClearSchedules(PRBool aWarnings) {
+      if (aWarnings && mScheduledForDELE)
+        NS_WARNING("Cancelling previously scheduled FTP file deletion");
+      if (aWarnings && mScheduledForMKD)
+        NS_WARNING("Cancelling previously scheduled FTP directory creation");
+      if (aWarnings && mScheduledForRMD)
+        NS_WARNING("Cancelling previously scheduled FTP directory removal");
+      if (aWarnings && mScheduledForRNFR)
+        NS_WARNING("Cancelling previously scheduled FTP file renaming");
+      mScheduledForDELE = PR_FALSE;
+      mScheduledForMKD  = PR_FALSE;
+      mScheduledForRMD  = PR_FALSE;
+      mScheduledForRNFR = PR_FALSE;
+      mScheduledNewURI = nsnull;
+    }
 
 private:
     nsCOMPtr<nsIProxyInfo>    mProxyInfo; 
@@ -129,6 +149,13 @@
     PRUint64                  mStartPos;
     nsCString                 mEntityID;
     PRPackedBool              mResumeRequested;
+
+    PRPackedBool              mScheduledForDELE;
+    PRPackedBool              mScheduledForMKD;
+    PRPackedBool              mScheduledForRMD;
+    PRPackedBool              mScheduledForRNFR;
+
+    nsCOMPtr<nsIURI>          mScheduledNewURI;
 };
 
 #endif /* nsFTPChannel_h___ */
diff -r 51249e968f24 netwerk/protocol/ftp/src/nsFtpConnectionThread.cpp
--- a/netwerk/protocol/ftp/src/nsFtpConnectionThread.cpp	Mon Nov 24 11:36:44 2008 +0100
+++ b/netwerk/protocol/ftp/src/nsFtpConnectionThread.cpp	Wed Jan 14 18:15:50 2009 +0100
@@ -1,4 +1,4 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* -*- Mode: C+; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /* vim:set tw=80 ts=4 sts=4 sw=4 et cin: */
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
@@ -637,6 +637,96 @@
 
             break;
             
+// DELE
+          case FTP_S_DELE:
+            rv = S_dele();
+
+            if (NS_FAILED(rv))
+                mInternalError = rv;
+            
+            MoveToNextState(FTP_R_DELE);
+            break;
+            
+          case FTP_R_DELE:
+            mState = R_dele();
+
+            if (FTP_ERROR == mState)
+                mInternalError = NS_ERROR_FAILURE;
+
+            break;
+            
+// MKD        
+          case FTP_S_MKD:
+            rv = S_mkd();
+
+            if (NS_FAILED(rv))
+                mInternalError = rv;
+            
+            MoveToNextState(FTP_R_MKD);
+            break;
+            
+          case FTP_R_MKD:
+            mState = R_mkd();
+
+            if (FTP_ERROR == mState)
+                mInternalError = NS_ERROR_FAILURE;
+
+            break;
+            
+// RMD        
+          case FTP_S_RMD:
+            rv = S_rmd();
+
+            if (NS_FAILED(rv))
+                mInternalError = rv;
+            
+            MoveToNextState(FTP_R_RMD);
+            break;
+            
+          case FTP_R_RMD:
+            mState = R_rmd();
+
+            if (FTP_ERROR == mState)
+                mInternalError = NS_ERROR_FAILURE;
+
+            break;
+            
+// RNFR
+          case FTP_S_RNFR:
+            rv = S_rnfr();
+
+            if (NS_FAILED(rv))
+                mInternalError = rv;
+            
+            MoveToNextState(FTP_R_RNFR);
+            break;
+            
+          case FTP_R_RNFR:
+            mState = R_rnfr();
+
+            if (FTP_ERROR == mState)
+                mInternalError = NS_ERROR_FAILURE;
+
+            break;
+
+// RNTO
+          case FTP_S_RNTO:
+            rv = S_rnto();
+
+            if (NS_FAILED(rv))
+                mInternalError = rv;
+            
+            MoveToNextState(FTP_R_RNTO);
+            break;
+            
+          case FTP_R_RNTO:
+            mState = R_rnto();
+
+            if (FTP_ERROR == mState)
+                mInternalError = NS_ERROR_FAILURE;
+
+            break;
+            
           default:
             ;
             
@@ -963,10 +1053,20 @@
 FTP_STATE
 nsFtpState::R_cwd() {
     if (mResponseCode/100 == 2) {
-        if (mAction == PUT)
+        switch (mAction) {
+          case PUT:
             return FTP_S_STOR;
-        
-        return FTP_S_LIST;
+          case DEL:
+            return FTP_S_DELE;
+          case MKDIR:
+            return FTP_S_MKD;
+          case RMDIR:
+            return FTP_S_RMD;
+          case RENAME:
+            return FTP_S_RNFR;
+          default:
+            return FTP_S_LIST;
+        }
     }
     
     return FTP_ERROR;
@@ -1354,6 +1454,15 @@
 
         port = ((PRInt32) (p0<<8)) + p1;
     }
+
+    if (mAction == DEL) 
+        return FTP_S_DELE;
+    if (mAction == MKDIR)
+        return FTP_S_MKD;
+    if (mAction == RMDIR)
+        return FTP_S_RMD;
+    if (mAction == RENAME)
+        return FTP_S_RNFR;
 
     PRBool newDataConn = PR_TRUE;
     if (mDataTransport) {
@@ -1604,11 +1713,12 @@
 
     nsresult rv;
     nsCAutoString path;
-    nsCOMPtr<nsIURL> url = do_QueryInterface(mChannel->URI());
+    mURI = mChannel->URI();
+    nsCOMPtr<nsIURL> url = do_QueryInterface(mURI);
     if (url) {
         rv = url->GetFilePath(path);
     } else {
-        rv = mChannel->URI()->GetPath(path);
+        rv = mURI->GetPath(path);
     }
     if (NS_FAILED(rv))
         return rv;
@@ -2217,3 +2327,123 @@
         free(p);
     return rv;
 }
+
+nsresult
+nsFtpState::SingleAbsolutePathCommand(FTP_ACTION aAction)
+{
+    NS_ASSERTION(mAction == aAction, "Wrong state to be here");
+    
+    nsCOMPtr<nsIURL> url = do_QueryInterface(mURI);
+    NS_ASSERTION(url, "I thought you were a nsStandardURL");
+
+    nsCAutoString str;
+    str.Append(mPwd);
+    str.Append(mPath);
+
+    NS_ASSERTION(!str.IsEmpty(), "What does it mean to deal with a empty path");
+
+    if (mServerType == FTP_VMS_TYPE)
+        ConvertFilespecToVMS(str);
+
+    NS_UnescapeURL(str);
+    switch(aAction) {
+      case DEL:
+        str.Insert("DELE ", 0);
+        break;
+      case MKDIR:
+        str.Insert("MKD ", 0);
+        break;
+      case RMDIR:
+        str.Insert("RMD ", 0);
+        break;
+      case RENAME:
+        str.Insert("RNFR ", 0);
+        break;
+      default:
+        // we never hit this
+        break;
+    }
+    str.Append(CRLF);
+
+    return SendFTPCommand(str);
+}
+
+
+nsresult
+nsFtpState::S_dele() {
+    return SingleAbsolutePathCommand(DEL);
+}
+
+FTP_STATE
+nsFtpState::R_dele() {
+    if (mResponseCode/100 == 2) {
+        //(DONE)
+        mNextState = FTP_COMPLETE;
+        return FTP_COMPLETE;
+    }
+
+   return FTP_ERROR;
+}
+
+nsresult
+nsFtpState::S_mkd() {
+  return SingleAbsolutePathCommand(MKDIR);
+}
+
+FTP_STATE
+nsFtpState::R_mkd() {
+   return R_dele();
+}
+
+nsresult
+nsFtpState::S_rmd() {
+    return SingleAbsolutePathCommand(RMDIR);
+}
+
+FTP_STATE
+nsFtpState::R_rmd() {
+   return R_dele();
+}
+
+nsresult
+nsFtpState::S_rnfr() {
+    return SingleAbsolutePathCommand(RENAME);
+}
+
+FTP_STATE
+nsFtpState::R_rnfr() {
+   if (mResponseCode/100 > 3)
+     return FTP_ERROR;
+
+   return FTP_S_RNTO;
+}
+
+nsresult
+nsFtpState::S_rnto() {
+    nsCAutoString sizeBuf;
+    mNewURI->GetPath(sizeBuf);
+
+    NS_UnescapeURL(sizeBuf);
+ 
+    sizeBuf.Insert(mPwd,0);
+
+    if (mServerType == FTP_VMS_TYPE)
+      ConvertFilespecToVMS(sizeBuf);
+    sizeBuf.Insert("RNTO ",0);
+    sizeBuf.Append(CRLF);
+
+    return SendFTPCommand(sizeBuf);
+}
+
+FTP_STATE
+nsFtpState::R_rnto() {
+    if (mResponseCode/100 == 2) {
+        //(DONE)
+        mNextState = FTP_COMPLETE;
+        // the renaming went well, let's update the channel's URI
+        mChannel->SetURI(mNewURI);
+        return FTP_COMPLETE;
+    }
+
+   return FTP_ERROR;
+}
diff -r 51249e968f24 netwerk/protocol/ftp/src/nsFtpConnectionThread.h
--- a/netwerk/protocol/ftp/src/nsFtpConnectionThread.h	Mon Nov 24 11:36:44 2008 +0100
+++ b/netwerk/protocol/ftp/src/nsFtpConnectionThread.h	Wed Jan 14 18:15:50 2009 +0100
@@ -104,11 +104,16 @@
     FTP_S_STOR, FTP_R_STOR,
     FTP_S_LIST, FTP_R_LIST,
     FTP_S_PASV, FTP_R_PASV,
-    FTP_S_PWD,  FTP_R_PWD
-} FTP_STATE;
+    FTP_S_PWD,  FTP_R_PWD,
+    FTP_S_DELE, FTP_R_DELE,
+    FTP_S_MKD,  FTP_R_MKD,
+    FTP_S_RMD,  FTP_R_RMD,
+    FTP_S_RNFR, FTP_R_RNFR,
+    FTP_S_RNTO, FTP_R_RNTO}
+FTP_STATE;
 
 // higher level ftp actions
-typedef enum _FTP_ACTION {GET, PUT} FTP_ACTION;
+typedef enum _FTP_ACTION {GET, PUT, DEL, MKDIR, RMDIR, RENAME} FTP_ACTION;
 
 class nsFtpChannel;
 
@@ -143,6 +148,29 @@
     nsFtpState();
     nsresult Init(nsFtpChannel *channel);
 
+    inline void ScheduleForFileDeletion(PRBool aEnabled) {
+      if (aEnabled)
+        mAction = DEL;
+    }
+    
+    inline void ScheduleForDirCreation(PRBool aEnabled) {
+      if (aEnabled)
+        mAction = MKDIR;
+    }
+
+    inline void ScheduleForDirRemoval(PRBool aEnabled) {
+      if (aEnabled)
+        mAction = RMDIR;
+    }
+
+    inline void ScheduleForRenaming(PRBool aEnabled, nsIURI * aNewURI) {
+      if (aEnabled)
+      {
+        mAction = RENAME;
+        mNewURI = aNewURI;
+      }
+    }
+
 protected:
     // Notification from nsBaseContentStream::AsyncWait
     virtual void OnCallbackPending();
@@ -169,6 +197,14 @@
     nsresult        S_stor(); FTP_STATE       R_stor();
     nsresult        S_pasv(); FTP_STATE       R_pasv();
     nsresult        S_pwd();  FTP_STATE       R_pwd();
+
+    nsresult        S_dele(); FTP_STATE       R_dele();
+    nsresult        S_mkd();  FTP_STATE       R_mkd();
+    nsresult        S_rmd();  FTP_STATE       R_rmd();
+
+    nsresult        S_rnfr(); FTP_STATE       R_rnfr();
+    nsresult        S_rnto(); FTP_STATE       R_rnto();
+
     // END: STATE METHODS
     ///////////////////////////////////
 
@@ -186,6 +222,7 @@
     nsresult BuildStreamConverter(nsIStreamListener** convertStreamListener);
     nsresult SetContentType();
     nsresult ConvertUTF8PathToCharset(const nsACString &aCharset);
+    nsresult SingleAbsolutePathCommand(FTP_ACTION aAction);
 
     /**
      * This method is called to kick-off the FTP state machine.  mState is
@@ -271,10 +308,13 @@
     nsresult            mInternalError; // represents internal state errors
 
         // ****** URI vars
+    nsCOMPtr<nsIURI>       mURI; 
     PRInt32                mPort;       // the port to connect to
     nsString               mFilename;   // url filename (if any)
     nsCString              mPath;       // the url's path
     nsCString              mPwd;        // login Path
+
+    nsCOMPtr<nsIURI>       mNewURI;     // the requested new path if we rename
 
         // ****** other vars
     nsCOMPtr<nsITransport>        mDataTransport;
